.TH "soundApi/soundApi.h" 3 "Thu May 5 2011" "Version version 0-02" "FAT FuriousAdvanceTracker" \" -*- nroff -*-
.ad l
.nh
.SH NAME
soundApi/soundApi.h \- 
.PP
Définition des fonctions implémentées par la soundApi GBA.  

.SH SYNOPSIS
.br
.PP
\fC#include 'register.h'\fP
.br

.SS "Fonctions"

.in +1c
.ti -1c
.RI "void \fBsnd_init_soundApi\fP ()"
.br
.RI "\fIInitialise le mode audio sur la Gameboy: active les 4 canaux. \fP"
.ti -1c
.RI "void \fBsnd_playSoundOnChannel1\fP (u16 sweeptime, u16 sweepdir, u16 sweepshifts, u16 volume, u16 envdir, u16 envsteptime, u16 waveduty, u16 soundlength, u16 loopmode, u16 sfreq, u8 transpose)"
.br
.RI "\fIJoue un son sur le channel 1. \fP"
.ti -1c
.RI "void \fBsnd_simple_playSoundOnChannel1\fP (u8 sweep, u16 envelope, u8 mode, u8 length, u16 noteFreq, u8 transpose)"
.br
.RI "\fIJoue un son sur le channel 1. \fP"
.ti -1c
.RI "void \fBsnd_playSoundOnChannel2\fP (u16 volume, u16 envdir, u16 envsteptime, u16 waveduty, u16 soundlength, u16 loopmode, u16 sfreq, u8 transpose)"
.br
.RI "\fIJoue un son sur le channel 2. \fP"
.ti -1c
.RI "void \fBsnd_simple_playSoundOnChannel2\fP (u16 envelope, u8 mode, u8 length, u8 noteFreq, u8 transpose)"
.br
.RI "\fIMéthode simplifiée pour jouer un son sur le channel 2. \fBNON IMPLEMENTE!\fP \fP"
.ti -1c
.RI "void \fBsnd_playSoundOnChannel3\fP (u16 volume, u16 soundLength, u16 loopmode, u16 voice, u16 bank, u16 bankMode, u16 freq, u8 transpose)"
.br
.RI "\fIJoue un son sur le channel 3. \fP"
.ti -1c
.RI "void \fBsnd_simple_playSoundOnChannel3\fP ()"
.br
.RI "\fIMéthode simplifiée pour jouer un son sur le channel 3. \fBNON IMPLEMENTE!\fP \fP"
.ti -1c
.RI "void \fBsnd_playSoundOnChannel4\fP (u16 volume, u16 envdir, u16 envsteptime, u16 soundlength, u16 loopmode, u16 shiftFreq, u16 stepping, u16 freqRatio, u8 transpose)"
.br
.RI "\fIJoue un son sur le channel 4. \fP"
.ti -1c
.RI "void \fBsnd_simple_playSoundOnChannel4\fP (u16 envelope, u8 mode, u8 length)"
.br
.RI "\fIMéthode simplifiée pour jouer un son sur le channel 4. \fBNON IMPLEMENTE!\fP \fP"
.ti -1c
.RI "void \fBsnd_stopAllSounds\fP ()"
.br
.RI "\fIEteint tout les sons en cours de lecture. \fP"
.ti -1c
.RI "void \fBsnd_tryToApplyEffect\fP (u8 channelId, u8 effectNumber, u8 effectValue)"
.br
.RI "\fICette fonction essaie d'appliquer en effet en dehors du contexte 'note': la commande sera appliquée sans jouer de note. \fP"
.in -1c
.SH "Description détaillée"
.PP 
Définition des fonctions implémentées par la soundApi GBA. 

Quelques règles à suivre :
.PP
.IP "\(bu" 2
toutes les fonctions sont préfixées par 'snd_' comme ca pas de risque de conflit.
.IP "\(bu" 2
les fonctions non testées sont préfixées par 'tmp_snd_', une fois testée -> on change en 'snd_'.
.IP "\(bu" 2
un petit commentaire au dessus de la fonction pour documenter. 
.PP

.SH "Documentation des fonctions"
.PP 
.SS "void snd_playSoundOnChannel1 (u16sweeptime, u16sweepdir, u16sweepshifts, u16volume, u16envdir, u16envsteptime, u16waveduty, u16soundlength, u16loopmode, u16sfreq, u8transpose)"
.PP
Joue un son sur le channel 1. \fBParamètres:\fP
.RS 4
\fIsweeptime\fP Temps de sweep de 0 à 7 
.br
\fIsweepdir\fP Direction du sweep 1 increase, 0 decrease 
.br
\fIsweepshifts\fP L'effet sweep de 0 à 7 
.br
\fIvolume\fP De 0 à F 
.br
\fIenvdir\fP Direction de l'enveloppe 1 increase, 0 decrease 
.br
\fIenvsteptime\fP Pas de l'enveloppe de 0 à 7 
.br
\fIwaveduty\fP Forme de l'onde 0, 1, 2 ou 3 
.br
\fIsoundlength\fP Durée du son 0 à 3f (attention valeur inversée: 3f = court) ACTIF seulement si loopmode = 1 
.br
\fIloopmode\fP Timed 1, continuous 0 
.br
\fIsfreq\fP Le numéro de fréquence de la note jouée. de 0 à 72 cf: const u16 freqs[NB_FREQUENCES] 
.br
\fItranspose\fP La valeur de transposition de 0 à FF 
.RE
.PP

.SS "void snd_playSoundOnChannel2 (u16volume, u16envdir, u16envsteptime, u16waveduty, u16soundlength, u16loopmode, u16sfreq, u8transpose)"
.PP
Joue un son sur le channel 2. \fBParamètres:\fP
.RS 4
\fIvolume\fP de 0 à F 
.br
\fIenvdir\fP direction de l'enveloppe 1 increase, 0 decrease 
.br
\fIenvsteptime\fP pas de l'enveloppe de 0 à 7 
.br
\fIwaveduty\fP forme de l'onde 0, 1, 2 ou 3f 
.br
\fIsoundlength\fP durée du son 0 à 3f (attention valeur inversée: 3f = court) ACTIF seulement si loopmode = 1 
.br
\fIloopmode\fP continuous 0, timed 1 
.br
\fIsfreq\fP le numéro de fréquence de la note jouée. de 0 à 72 cf: const u16 freqs[NB_FREQUENCES] 
.br
\fItranspose\fP le paramètre de transposition 
.RE
.PP

.SS "void snd_playSoundOnChannel3 (u16volume, u16soundLength, u16loopmode, u16voice, u16bank, u16bankMode, u16freq, u8transpose)"
.PP
Joue un son sur le channel 3. \fBParamètres:\fP
.RS 4
\fIvolume\fP 0 à 4 
.br
\fIsoundLength\fP durée du son de 0 a FF (valeur inversée: FF = très court) 
.br
\fIloopmode\fP timed = 1, continuous = 0 
.br
\fIvoice\fP numéro de la voix à jouer 
.br
\fIbank\fP numéro de la bank à jouer 0 ou 1 (appliqué seulement si bankMode = 1) 
.br
\fIbankMode\fP single 0, dual 1 
.br
\fIfreq\fP le numéro de fréquence de la note jouée. de 0 à 72 cf: const u16 freqs[NB_FREQUENCES] 
.br
\fItranspose\fP le paramètre de transposition 
.RE
.PP

.SS "void snd_playSoundOnChannel4 (u16volume, u16envdir, u16envsteptime, u16soundlength, u16loopmode, u16shiftFreq, u16stepping, u16freqRatio, u8transpose)"
.PP
Joue un son sur le channel 4. \fBParamètres:\fP
.RS 4
\fIvolume\fP de 0 à F 
.br
\fIenvdir\fP direction de l'enveloppe 1 increase, 0 decrease 
.br
\fIenvsteptime\fP pas de l'enveloppe de 0 à 7 
.br
\fIsoundlength\fP durée du son 0 à 3f (attention valeur inversée: 3f = court) ACTIF seulement si loopmode = 1 
.br
\fIloopmode\fP timed 1, continuous 0 
.br
\fIshiftFreq\fP 
.br
\fIstepping\fP 
.br
\fIfreqRatio\fP 
.br
\fItranspose\fP 
.RE
.PP

.SS "void snd_simple_playSoundOnChannel1 (u8sweep, u16envelope, u8mode, u8length, u16noteFreq, u8transpose)"
.PP
Joue un son sur le channel 1. \fBParamètres:\fP
.RS 4
\fIsweep\fP Combinaison de tous les paramètres sweep (sweeptime, sweepdir, sweepshifts) de 0 à FF. 
.br
\fIenvelope\fP Combinaison de tous les paramètres pour l'enveloppe (volume, envdir, envsteptime, waveduty) de 0 à FFFF 
.br
\fImode\fP Timed 1, continuous 0 
.br
\fIlength\fP Durée du son 0 à 3f (attention valeur inversée: 3f = court) ACTIF seulement si loopmode = 1 
.br
\fInoteFreq\fP Le numéro de fréquence de la note jouée. de 0 à 72 cf: const u16 freqs[NB_FREQUENCES] 
.br
\fItranspose\fP La valeur de transposition de 0 à FF.
.RE
.PP
Cette méthode est plus simple que snd_playSoundOnChannel1 mais produit le même résultat. 
.SS "void snd_simple_playSoundOnChannel2 (u16envelope, u8mode, u8length, u8noteFreq, u8transpose)"
.PP
Méthode simplifiée pour jouer un son sur le channel 2. \fBNON IMPLEMENTE!\fP \fBParamètres:\fP
.RS 4
\fIenvelope\fP 
.br
\fImode\fP 
.br
\fIlength\fP 
.br
\fInoteFreq\fP 
.br
\fItranspose\fP 
.RE
.PP

.SS "void snd_tryToApplyEffect (u8channelId, u8effectNumber, u8effectValue)"
.PP
Cette fonction essaie d'appliquer en effet en dehors du contexte 'note': la commande sera appliquée sans jouer de note. \fBParamètres:\fP
.RS 4
\fIchannelId\fP le numéro de channel sur lequel appliquer l'effet 
.br
\fIeffectNumber\fP le numéro d'effet à appliquer 
.br
\fIeffectValue\fP la valeur de l'effet 
.RE
.PP

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour FAT FuriousAdvanceTracker à partir du code source.
